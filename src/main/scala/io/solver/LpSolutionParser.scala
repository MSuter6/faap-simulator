package io.solver

import GraphDefinition.GraphNode
import better.files.File
import simulator.Mapping.Mapping
import simulator.allocation._
import simulator.{FaapProblemInstance, Mapping}

/**
  * Provides functionality to parse the files generated by the Solvers (SCIP, Gurobi).
  */
object LpSolutionParser {
  def parseLpSolution(file: File, faapProblemInstance: FaapProblemInstance, config: SolverAllocatorConfig): Mapping = {
    val lineIterator = file.lineIterator

    if (lineIterator.isEmpty) {
      throw new LpSolverFailedToFindSolutionException("No feasible solution seems to exist for this problem instance (Gurobi)")
    }

    val firstLine = lineIterator.next()
    if (firstLine.contains("infeasible") || firstLine.contains("unknown")) {
      throw new LpSolverFailedToFindSolutionException("No feasible solution seems to exist for this problem instance (SCIP)")
    }

    import simulator.allocation.Solver._

    val solver = if (firstLine.startsWith("# Solution for model")) Gurobi else if (firstLine.startsWith("solution status:")) SCIP

    assert(solver == config.solver)

    val mapping = solver match {
      case SCIP =>
        config.formulation match {
          case _: LpRoundingZimplWriter =>
            computeRoundedMapping(faapProblemInstance, lineIterator)
          case _ =>
            lineIterator.filter(_.startsWith("y$")).map(mapLine => {
              val splitted = mapLine.substring(0, mapLine.indexOf(" ")).split('$')
              getOuterNodeFromString(splitted(1), faapProblemInstance.appGraph.nodes.toOuter) -> getOuterNodeFromString(splitted(2), faapProblemInstance.fogGraph.nodes.toOuter)
            })
        }
      case Gurobi =>
        faapProblemInstance.appGraph.nodes.map(node => {
          val lineIterator = file.lineIterator

          val nodeLines = lineIterator.filter(_.startsWith(s"y$$${node.toOuter.getIdString}$$"))

          val maxLine = nodeLines.maxBy(_.split(" ")(1).toDouble)

          val splitted = maxLine.substring(0, maxLine.indexOf(" ")).split('$')
          getOuterNodeFromString(splitted(1), faapProblemInstance.appGraph.nodes.toOuter) -> getOuterNodeFromString(splitted(2), faapProblemInstance.fogGraph.nodes.toOuter)
        })
    }

    Mapping(mapping.toSeq: _*)
  }

  private def getOuterNodeFromString[N <: GraphNode](nodeString: String, nodes: Set[N]): N = {
    val matchingNode = nodes.filter(_.getIdString == nodeString)
    if (matchingNode.isEmpty || matchingNode.size > 1) {
      throw new AllocationException(s"ILP solver didn't find a correct solution (node string: $nodeString)")
    }
    matchingNode.head
  }

  /**
    * If the relaxed ZIMLP/ILP formulation is used, the mappings are not binary. Therefore they have to be rounded.
    * This approach works, but it does not produce sufficiently good results (i.e. the heuristics have a better performance).
    */
  private def computeRoundedMapping(problemInstance: FaapProblemInstance, lineIterator: Iterator[String]): Mapping = {
    case class RoundingAllocatorState(faapProblemInstance: FaapProblemInstance = problemInstance) extends GreedyAllocatorState {
      override protected var mapping: Mapping = Mapping.empty

      val outerAppNodes: Set[GraphDefinition.AppNode] = problemInstance.appGraph.nodes.toOuter
      val outerFogNodes: Set[GraphDefinition.FogNode] = problemInstance.fogGraph.nodes.toOuter
    }

    val state = RoundingAllocatorState()

    val nodeLines = lineIterator.filter(_.startsWith("y"))

    val pMap = nodeLines.map(line => {
      val sanitizedLine = line.trim.replaceAll(" +", " ")

      val (appNodeId, fogNodeId, p) = sanitizedLine.split(" ") match {
        case Array(idString, weightString, _) =>
          val weight = weightString.toDouble
          val (appNodeId, fogNodeId) = idString.split('$') match {
            case Array(_, appString, fogString) => (appString, fogString)
            case _ => throw new LpSolverFailedToFindSolutionException(s"Failed to find a lp relax rounding solution (line $line could not be parsed)")
          }
          (appNodeId, fogNodeId, weight)
        case _ =>
          throw new LpSolverFailedToFindSolutionException(s"Failed to find a lp relax rounding solution (line $line could not be parsed)")
      }

      (appNodeId, fogNodeId, p)
    }).toList.sortBy(-_._3)

    pMap.foreach { case (appId, fogId, _) =>
      if (state.allNodesMapped) {
        return state.getMapping
      }
      val appNode = getOuterNodeFromString(appId, state.outerAppNodes)
      val fogNode = getOuterNodeFromString(fogId, state.outerFogNodes)

      if (!state.getMapping.isDefinedAt(appNode)) {
        val innerFogNode = state.faapProblemInstance.fogGraph.get(fogNode)
        if (state.fogNodeCpuRemainingResources(innerFogNode) >= appNode.resourceUsage) {
          state.addMapping(appNode, innerFogNode)
        }
      }
    }
    if(state.allNodesMapped) {
      state.getMapping
    } else {
      GreedyBorderAllocator.runAllocation(FaapProblemInstance(problemInstance.repetition,
        problemInstance.appGraph,
        problemInstance.fogGraph,
        Some(state.getMapping),
        problemInstance.latencyPaths,
        problemInstance.id))
    }
  }
}
